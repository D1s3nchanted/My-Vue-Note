**JavaScript基础笔记**



- JavaScript结构：ECMAScript（JavaScript语法）、DOM（页面文档对象模型）、BOM（浏览器对象模型）



- JavaScript书写位置：行内、内嵌和外部



- - 行内式JS：**<input type="button" value="点我试试" onclick="alert('Hello World!')" />**（**几乎不用**）



- - 内嵌式JS：**<script>alert('Hello World!');</script>** 写在**<head>**标签中，是最常用的方式（JS中推荐多使用单引号）



- - 外部JS文件：**<script src="my.js"></script>** （**引用外部JS文件的script标签中间不可以写代码**）



- JavaScript输入输出语句



- - **alert('')**：浏览器弹出警示框



- - **console.log('')**：浏览器控制台打印输出信息



- - **prompt('')**：浏览器弹出输入框，用户可以输入（等于input）



- JavaScript变量



- - 声明变量：**var 变量名='值';**



- - 声明多个变量：**var age = 10, name = 'zs', sex = 2;**



- - 定义变量名时，不能以数字开头，如**var 18age;**



- - 遵守驼峰命名法：首字母小写，后面单词首字母大写，如：**myFirstName**



- - 不要使用**name**作为变量名



- JavaScript数据类型



- - 简单数据类型（Number, String, Boolean, Undefined, Null）

  - - **Undefined**：声明了变量但没有给值，此时变量为**undefined**，例：**var a; → a = undefined**
    - **Null**：声明了变量为空值，例：**var a = null;**



- - 复杂数据类型（object）





- **isNaN()**：用来判断是否是数字，是数字返回**False**，不是数字返回**True（NaN=Not a number）**



- 字符串转义符



- - **\n**：换行符



- - **\t**：tab缩进



- - **\b**：空格



- 字符串长度：**str.length**



- 获取检测变量的数据类型：**typeof**



- 数据类型转换：使用表单、prompt获取过来的数据默认是字符串类型的，所以需要数据类型转换



- - **toString()**：转换为字符串，例：**var num = 10; var str = num.toString();**



- - **String()**强制转换字符串



- - **加号拼接字符串，例：console.log(num + '');**



- - 转换为数字型（**重点**）：



- - - **parseInt(String)**：将string类型转成整数数值型，例：**parseInt('120');**



- - - **parseFloat(String)**：将string类型转成浮点数数值型，例：**parseFloat('3.14');**



- - - **Number()**：将string类型转换为数值型，例：**Number('12');**



- - - js隐式转换（- * /）：利用算术运算隐式转换为数值型，例：**console.log('12' - 0);**

注意⚠️：若**parseFloat('120px');** 会去掉px单位→ **120**。若**parseFloat('rem120px');** → **NaN**



- - 转换为布尔型：**Boolean()**函数，例：**Boolean('true');**

  - - 代表空、否定的值会被转换为**false**，如**''**、**0**、**NaN**、**null**、**undefined**
    - 其余值都会被转换为**true**



- JavaScript运算符



- - 算术运算符：**+**、**-**、*****、**/**、**%**（除取余）



- - 递增运算符（**++**）和递减运算符（**--**）：

  - - 前置递增（递减）运算符：**++num**就等于**num=num+1**
    - 后置递增（递减）运算符：**num=10;** **num++ +10 → 20 num→11**
    - 前置自增和后置自增如果单独使用，效果是一样的
    - 后置自增口诀是：先返回原值，后自加。



- - 比较运算符：

  - - **==**：判断是否相等（默认转换数据类型），例：**18=='18';** → **true**
    - **===** **!==**：全等，要求值和数据类型都一致



- - 逻辑运算符：用来进行布尔值运算的运算符，其返回值也是布尔值，常用于多个条件的判断

  - - **&&**：与and，例：**true && false → false（有一个为假即为假）**
    - **||**：或or，例：**true || false → true（有一个真即为真）**
    - **!**：非not，例：**!true → false**
    - 短路运算（逻辑中断）



- - - - 原理：当有多个表达式（值）时，左边的表达式可以确定结果时，就不再继续运算右边的表达式的值。



- - - - 逻辑**与**短路运算：

      - - 语法：**表达式1 && 表达式2**
        - 如果第一个表达式的值为真，则返回表达式2，例：**123 && 456** → **456**
        - 如果第一个表达式的值为假，则返回表达式1，例：**0 && 456** → **0   0 && 1 + 2 && 456 \*56789** → **0**



- - - - 逻辑**或**短路运算：

      - - 语法：**表达式1 || 表达式2**
        - 如果第一个表达式的值为真，则返回表达式1，例：**123 || 456** → **123  123 || 456 || 456 + 123** → **123**
        - 如果第一个表达式的值为假，则返回表达式2，例：**0 || 456** → **456**



- - 赋值运算符：

  - - **=**：直接赋值
    - **+=**、**-=**：加、减一个数后再赋值
    - ***=**、**/=**、**%=**：乘、除、取模后再赋值



- - 运算符优先级：

  - - 算术运算符：先***/%**，后**+-**
    - 逻辑运算符：先**&&**，后**||**



- JavaScript if else语句

- - 语法：**if（条件表达式）{ 执行语句1 } else if (条件表达式2)  {执行语句2} else {执行语句3}**



- JavaScript三元表达式

- - 语法：**条件表达式 ? 表达式1: 表达式2**
  - 执行思路：如果条件表达式结果为真，则返回表达式1的值；如果条件表达式结果为假，则返回表达式2的值。



- Switch语句

- - 语法：

```javascript
switch(表达式){
  case value1:
    执行语句1;
    break;
  case value2:
    执行语句2;
    break;
  ...
  default:
  	执行最后的语句;
}
```

- - 执行思路：利用我们的表达式的值和case后面的选项值相匹配（全等，数据类型和值都相等），如果匹配上，就执行该**case**里面的语句。如果都没有匹配上，那么执行**default**里面的语句。
  - 如果当前的**case**里面没有**break**，则不会退出**switch**，继续执行下一个**case**



- Switch语句与if else if 语句的区别：

- - 一般情况下，它们两个语句可以相互替换
  - **switch...case**语句通常处理case为比较确定值的情况，而**if...else...**语句更加灵活，常用于范围判断（大于、等于某个范围）
  - switch语句进行条件判断后直接执行到程序的条件语句，效率更高，而**if...else**语句有几种条件，就得判断多少次
  - 当分支比较少时，**if...else**语句的执行效率比**switch**语句高
  - 当分支比较多时，**switch**语句的执行效率比较高，而且结构更清晰



- 循环



- - **for**循环

  - - 语法：**for (初始化变量; 条件表达式; 操作表达式) { 循环体 }**
    - 初始化变量 就是用**var**声明的一个普通变量，通常用于作为计数器使用
    - 条件表达式 就是用来决定每一次循环是否继续执行 就是终止的条件
    - 操作表达式 是每次循环最后执行的代码 经常用于我们计数器变量进行更新（递增或者递减）



- - **do...while**循环

  - - 语法：**do {循环体} while (条件表达式)**
    - **do...while** 和 **while**循环的不同点在于，**do...while**会先进行一次循环，再判断条件，如果条件表达式结果为真，则继续执行循环体，否则退出循环



- - **Continue**关键字：退出本次（当前次的循环），继续执行剩余的循环



- - **break**关键字：立即跳出整个循环



- 数组



- - 创建数组

  - - - 利用new关键字创建数组：**var arr = new Array(); （了解即可）**

    - 利用数组字面量创建数组：**var arr = [];**



- - 遍历数组

  - - **for (i=0; i<数组长度; i++) {循环体}**



- - 数组长度：**arr.length**



- - 新增数组元素（不能直接给数组名赋值，否则里面的数组元素全都没有了）

  - - 修改length长度
    - 修改数组索引



- - 冒泡排序：是一种算法，把一系列的数据按照一定的顺序进行排列显示（从小到大或从大到小）

- ![截屏2022-07-02 17.56.53.png](blob:file:///14319a64-dbde-45af-b259-d6bb5b0c65c7)

```javascript
var arr = [5, 4, 3, 2, 1];
for(var i=0; i <= arr.length; i++){
  for(var j = 0; j <= arr.length - i - 1; j++){
    //内部交换两个变量的值 前一个和后一个数组元素相比较
    if(arr[j] > arr[j+1]){
      var temp = arr[j];
      arr[j] = arr[j+1];
      arr[j+1] = temp;
    }
  }
}
```

- JavaScript函数



- - 语法：**function 函数名(参数) {函数体}      var fun = function(参数) {函数体}**



- - 调用函数：**函数名(参数);**



- - 形参和实参

  - - 若实参个数多于形参个数，会取到形参的个数，多的实参不参与
    - 若实参个数少于形参个数，没有接收到实参的形参会返回**undefined**，最终整个函数返回**NaN**



- - **return**后面的代码不会被执行，且**return**只能返回一个值。若想返回多个值，可以直接返回一个数组（若函数没有**return**，则返回**undefined**）



- - **arguments**的使用：当我们不确定有多少个参数传递的时候，可以用**arguments**来获取。在JS中，**arguments**实际上是当前函数的一个内置对象。所有函数都内置了一个**arguments**对象，其中存储了传递的所有实参。

  - - arguments展示形式是一个伪数组，因此可以进行遍历。



- - 伪数组：并不是真正意义上的数组

  - - 具有数组的**length**属性
    - 按照索引的方式进行存储的
    - 它没有真正数组的一些方法 **pop()** **push()** 等等



- JavaScript作用域（ES5，ES6有块级作用域）



- - 全局作用域：整个script标签，或者是一个单独的JS文件



- - 局部作用域：在函数内部就是局部作用域，这个代码的名字只在函数内部起效果和作用



- 变量的作用域（对象不产生作用域，即对象中的this指向window）



- - 全局变量：在全局作用域下的变量，在全局下都可以用

  - - 注意⚠️：如果在函数内部没有声明（**var**）直接赋值的变量也属于**全局变量**



- - 局部变量：在局部作用域下的变量，在函数内部的变量就是局部变量

  - - 注意⚠️：函数的形参也可以看做是局部变量



- - 从执行效率来看：

  - - 全局变量只有浏览器关闭的时候才会销毁，比较占内存资源
    - 局部变量当程序执行完毕的时候就会销毁，比较节约内存资源



- 作用域链

- - 只要是代码，就一定有作用域
  - 写在函数内部的局部作用域
  - 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域
  - 根据在内部函数可以访问外部函数变量的这种机制，用链式查找（往上一级找，如果找到就执行，没找到就再往上一级查找）决定哪些数据能被内部函数访问，就称作作用域链



- JavaScript预解析



- - JS引擎运行JS分为两步：预解析、代码执行

  - - **预解析**：JS引擎会把JS里面所有的**var**还有**function**提升到当前作用域的最前面
    - 代码执行：按照代码书写的顺序从上往下执行



- - 预解析分为：变量预解析（变量提升）和函数预解析（函数提升）

  - - 变量提升：就是把所有的变量声明提升到当前的作用域最前面，**不提升赋值操作（例：var sum=10; 在提升时只会提升var sum;）**



- JavaScript对象



- - 对象是由**属性**和**方法**组成的



- - 创建对象(object)的三种方式



- - - 利用**字面量**创建对象

    - - 对象字面量：就是花括号{ }里面包含了表达这个具体事物（对象）的属性和方法

      - - 语法：里面的属性或者方法采取**键值对**的形式，多个属性或者方法中间用逗号隔开，方法冒号后面跟的是一个匿名函数

        - 使用对象

        - - 调用对象属性：**对象名.属性名** 或 **对象名['属性名']**
          - 调用对象的方法：**对象名.方法名()** 千万别忘记小括号

```javascript
var obj = {
  uname:'张三丰',
  age:18,
  sex:'男',
  sayHi:function(){
    console.log('hi~');
  }
}
```

- - - 利用**new object**创建对象

    - - 语法：利用等号赋值的方法添加对象的属性和方法，每个属性和方法之间用分号结束

```javascript
var obj = new Object();
obj.uname = '张三丰';
obj.age = 18;
obj.sex = '男';
obj.sayHi = function(){
  console.log('hi~');
}
```

- - - 利用**构造函数**创建对象：因为我们一次创建一个对象，里面很多属性和方法是大量相同的，我们只能复制，因此我们可以利用函数的方法，重复这些相同的代码，我们把这个函数称为 **构造函数（里面封装的不是普通代码，而是对象）**

    - - 语法：构造函数名字首字母要大写，构造函数不需要**return**就可以返回结果。要调用构造函数，就必须使用**new**。属性和方法前面一定要加**this**
      - 实例成员：实例成员就是构造函数内部通过**this**添加的成员，**name age sex**就是实例成员，实例成员只能通过实例化的对象来访问
      - 静态成员：在构造函数本身上添加的成员，静态成员只能通过构造函数来访问 **Star.sex = '男';**

```javascript
//创建对象
function 构造函数名(){
  this.属性 = 值;
  this.方法 = function(){}
}
//调用对象
new 构造函数名();
```

例：

```javascript
function Star(uname, age, sex){
  this.name = uname;
  this.age = age;
  this.sex = sex;
}
new Star('刘德华', 18, '男');
```

- - 遍历对象

  - - 语法：

```javascript
for(var k in obj){
  console.log(k); //k变量 输出 得到的是 属性名
  console.log(obj[k]); //obj[k]得到的是 属性值
}
```

- JavaScript内置对象



- - JavaScript对象分为三种：自定义对象、内置对象、浏览器对象



- - Math对象（不是构造函数）



- - - **Math.max(num1,num2,num3)**：最大值（若传入的参数有不是数字的，会返回**NaN**；若没有传入参数，返回的是**-Infinity**）



- - - **Math.abs(num)**：绝对值（若输入的是字符串'-1'，则会隐式转换为数字型，返回1）



- - - **Math.floor()**：向下取整，往最小了取值，例：**Math.floor(1.1)** → **1**   **Math.floor(1.9)** → **1**



- - - **Math.ceil()**：向上取整，往大了取值，例：**Math.floor(1.1)** → **2   Math.floor(1.9)** → **1**



- - - **Math.round()**：四舍五入，其他数字都是四舍五入，但.5特殊，它往大了取。例：**Math.round(1.4)** → **1**   **Math.round(1.5)** → **2   Math.round(-1.5)** → **-1**



- - - **Math.random()**：随机数方法，返回一个随机小数 0 <= x < 1，这个方法里面**不跟参数（直接Math.random()调用）**

    - - 得到两个数之间的随机整数，并且包含这两个整数，写法：

```javascript
//两个数之间的随机整数，包含这两个整数
function getRandom(min, max){
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
console.log(getRandom(1,10));
```

- - Date对象：是一个构造函数，必须使用**new**来调用创建日期对象



- - - 语法：**var date = new Date();** （若没有参数，则返回当前系统的当前时间）



- - - 参数常用的写法

    - - 数字型：**2019,10,01**
      - 字符串型：**'2019-10-1 8:8:8'**（**常用**）



- - - 常用方法

    - - **date.getFullYear()**：返回当前日期的**年份**
      - **date.getMonth() + 1**：返回当前日期的**月份**，返回的月份小1个月，**记得月份+1**
      - **date.getDate()**：返回的是几号
      - **date.getDay()**：返回的是周几，周一返回的是1，周六返回的是6，**周日返回的是0**
      - **date.getHours()**：返回小时
      - **date.getMinutes()**：返回分钟
      - **date.getSeconds()**：返回秒数



- - - 获取日期的总的毫秒形式（时间戳）：Date对象是基于1970年1月1日（世界标准时间）起的毫秒数

    - - 语法：**var date = +new Date();** //获取现在时间距离1970.1.1总的毫秒数
      - H5新增的 获得总的毫秒数：**Date.now()**



- - - 做**倒计时**需要用：**将来的时间戳-现在的时间戳**

```javascript
function countDown(time){
  var nowTime = +new Date(); //返回的是当前时间总的毫秒数
  var inputTime = +new Date(time); //返回的是用户输入时间总的毫秒数
  var times = (inputTime - nowTime) / 1000; //times是剩余时间总的秒数
  var d = parseInt(times / 60 / 60 / 24); //天
  d = d < 10 ? '0' + d : d;
  var h = parseInt(times / 60 / 60 % 24); //时
  h = h < 10 ? '0' + h : h;
  var m = parseInt(times / 60 % 60); //分
  m = m < 10 ? '0' + m : m;
  var s = parseInt(times % 60); //秒
  s = s < 10 ? '0' + s : s;
  return d + '天' + h + '时' + m + '分' + s + '秒';
}
```

- 创建数组的两种方式



- - 利用数组字面量：**var arr = [1,2,3];**



- - 利用new Array()：**var arr = new Array();** （创建一个空的数组）

  - - 若是**Array(2)**表示创建两个空的数组元素
    - 若是**Array(2,3)**表示里面有数组元素2和3



- 检测是否为数组

- - **instanceof**运算符，它可以用来检测是否为数组（**arr instanceof Array**，返回布尔值）
  - H5新增方法：**Array.isArray(参数)**：传入的参数就是**要检测的值**



- 添加数组元素

- - **push()**：在数组末尾添加一个或者多个数组元素（push完毕之后，返回的结果是新数组的长度）
  - **unshift()**：在数组的开头添加一个或多个数组元素（unshift完毕之后，返回的结果是新数组的长度）



- 删除数组元素

- - **pop()**：删除数组的最后一个元素（没有参数，返回值是删除的元素）
  - **shift()**：删除数组的第一个元素（没有参数，返回值是删除的元素）



- 数组排序

- - 翻转数组：**arr.reverse();**

  - 数组排序（冒泡排序）：**arr.sort();**

  - - **一般写作arr.sort(function(a,b) {return a-b;}) （升序）**
    - **arr.sort(function(a,b) {return b-a;}) （降序）**



- 获取数组索引方法



- - **indexOf(数组元素)**：返回该数组元素的索引号（若重复，则只返回**第一个**满足条件的索引号。若传入的参数不存在，则返回**-1**。）

  - - 语法：**str.indexOf('要查找的字符', [起始的位置])**



- - **lastIndexOf(数组元素)**：返回该数组元素的索引号（若重复，则只返回**最后一个**满足条件的索引号。若传入的参数不存在，则返回**-1**。）



- 数组转换为字符串



- - **toString()**：把数组转换成字符串，逗号分隔每一项



- - **join('分隔符')**：方法用于把数组中的所有元素转换为一个字符串



- 字符串的不可变性：字符串里面的值不可变，虽然再次赋值看上去可以改变内容，但其实是内存地址变了，内存中新开辟了一个内存空间（因此**不要大量拼接字符串**）



- 根据字符返回位置：字符串的所有方法，都不会修改字符串本身（本身不可变性），操作完成会返回一个新的字符串



- 案例：查找字符串'abcoefoxyozzopp'中所有o出现的位置及次数

```javascript
//查找字符串'abcoefoxyozzopp'中所有o出现的位置及次数
//核心算法：先查找第一个o出现的位置
//然后 只要indexOf 返回的结果不是-1 就继续往后查找
//因为indexOf 只能查找到第一个 所以后面的查找 一定是当前索引加1，从而继续查找
var str = 'abcoefoxyozzopp';
var index = str.indexOf('o');
var num = 0;
while(index !== -1){
  console.log(index);
  num++;
  index = str.indexOf('o', index + 1);
}
console.log('o出现的次数是' + num);
```

- 根据位置返回字符



- - **charAt(index)**：返回指定位置的字符（index字符串的索引号）



- - **charCodeAt(index)**：获取指定位置处字符的ASCII码（用来判断用户按了哪个键，A对应65，a对应97）



- - **str[index]**：获取指定位置处的字符（HTML5新增的）



- 字符串操作方法（重点）



- - concat(str1, str2, str3...)：concat()方法用于连接两个或多个字符串。拼接字符串，等效于+，**+更常用**



- - **substr(start, length)**：从start位置开始（索引号），length 取的个数 **重点记住这个**



- - slice(start, end)：从start位置开始，截取到end位置，end取不到（他们俩都是索引号）



- - substring(start, end)：从start位置开始，截取到end位置，end取不到 基本和slice相同，但是不接受负值



- - **replace('被替换的字符'， '替换为的字符')**：替换字符



- - **split('分隔符')**：字符转换为数组



- JavaScript简单数据类型和复杂数据类型



- - 值类型：简单数据类型，在存储时变量中存储的是值本身，因此叫做值类型

  - - string
    - number
    - boolean
    - undefined
    - null：返回的是一个空的对象（object），如果有个变量以后打算存储为对象，暂时没想好放啥，就给null



- - 引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型

  - - 通过new关键字创建的对象（系统对象、自定义对象），如Object、Array、Date等



- 堆和栈



- - **栈**（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的**栈**。简单数据类型存放到**栈**里面



- - **堆**（操作系统）：存储复杂类型（对象），一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型存放到**堆**里面



**注意**⚠️：JavaScript中没有堆、栈的概念，通过堆栈的方式，可以更容易理解代码的一些执行方式。



\--------------------------------------------------------------------------------------------------------------------------------------------------------------------------



- JavaScript Web APIs



- - API：应用程序编程接口，简单理解就是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能



- - Web API：是浏览器提供的一套操作**浏览器功能**和**页面元素**的**API（DOM**和**BOM）**



- DOM：文档对象模型，是W3C组织推荐的处理可扩展标记语言（HTML或者XML）的标准**编程接口**



- - DOM树

  - - 文档：一个页面就是一个文档，DOM中使用**document**表示
    - 元素：页面中的所有标签都是元素，DOM中使用**element**表示
    - 节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM中使用**node**表示
    - DOM把以上内容都看做是**对象**

![截屏2022-07-07 10.35.26.png](blob:file:///e5569d27-0951-4be7-b420-83c068b68d3b)



- - 获取元素



- - - 根据**ID**获取

    - - **document.getElementById('id')**：参数ID是**大小写敏感的字符串**，返回的是一个元素对象



- - - 根据**标签名**获取

    - - **getElementsByTagName('标签名')**：返回带有指定标签名的对象的集合**[li, li, li, li]**

      - - 如果页面中只有一个**li**，返回的还是伪数组的形式**[li]**
        - 如果页面中没有这个元素，返回空的伪数组**[]**

      - **element.getElementsByTagName('标签名')**：获取某个元素（父元素）内部所有指定标签名的子元素

      - - 注意：父元素必须是**单个对象（必须指明是哪一个元素对象）**。获取的时候不包括父元素自己



- - - 通过HTML5新增的方法获取

    - - **document.getElementsByClassName('标签名')**：根据类名获得某些元素集合
      - **document.querySelector('选择器')**：根据指定选择器返回**第一个元素对象**，例：**document.querySelector('.box')或document.querySelector('#nav')**
      - **document.querySelectorAll('选择器')**：返回指定选择器的**所有元素对象**集合



- - - 特殊元素获取（body, html）

    - - 获取body：**document.body**
      - 获取html：**document.documentElement**



- - 事件：JS使我们有能力创建动态页面，而事件是可以被JS侦测到的行为（简单理解：触发--响应机制）



- - - 事件源：事件被触发的对象



- - - 事件类型：如何触发 什么事件 比如鼠标点击（**onclick**）还是鼠标经过 还是键盘按下



- - - 事件处理程序

```javascript
//点击一个按钮，弹出对话框
//事件是由三部分组成 事件源 事件类型 事件处理程序 我们也称为事件三要素
//（1）事件源 事件被触发的对象 谁 按钮
var btn = document.getElementById('btn');
//（2）事件类型 如何触发 什么事件 比如鼠标点击（onclick）还是鼠标经过 还是键盘按下
//（3）事件处理程序 通过一个函数赋值的方式完成
btn.onclick = function(){
  alert('点秋香');
}
```



- - 操作元素：JS的DOM操作可以改变网页内容、结构和样式，我们可以利用DOM操作元素来改变元素里面的内容、属性等。注意以下都是属性



- - - 改变元素内容



- - - - **element.innerText**：从起始位置到终止位置的内容，但它去除html标签，同时空格和换行也会去掉

      - - 不识别HTML标签、非标准、会去除空格和换行



- - - - **element.innerHTML**：起始位置到终止位置的全部内容，包括html标签，同时保留空格和换行（**常用**）

      - - 识别HTML标签、W3C标准、保留空格和换行



- - - 表单元素的属性操作

    - - 利用DOM可以操作如下表单元素的属性：**type**、**value**、**checked**、**selected**、**disabled(disabled=true)**
      - 表单里面的值，文字内容是通过**value**来修改的



- - - 样式属性操作

    - - **element.style**：行内样式操作
      - **element.className**：类名样式操作（先在CSS中写好类，再将类名赋给操作）
      - 注意：1.JS里面样式采取驼峰命名法，如**fontSize**、**backgroundColor**。2.JS修改style样式操作，产生的是行内样式，JS行内权重比较高。
      - 获得焦点事件：**onfocus**
      - 失去焦点事件：**onblur**
      - 鼠标经过事件：**onmouseover**
      - 鼠标离开事件：**onmouseout**



- - - 排他思想：如果有同一组元素，我们想要某一个元素实现某种样式，需要用到循环的排他思想算法

    - - 所有元素全部清除样式（干掉其他人）
      - 给当前元素设置样式（留下我自己）



- - - 自定义属性操作



- - - - 获取属性值

      - - **element.属性**：获取内置属性值（元素本身自带的属性）
        - **element.getAttribute('属性')**：主要获得自定义的属性（标准）我们程序员自定义的属性



- - - - 设置属性值

      - - **element.属性 = '值'** ：设置内置属性值
        - **element.setAttribute('属性', '值')** ：主要针对于自定义属性



- - - - 移除属性

      - - **element.removeAttribute('属性')**



- - - - H5自定义属性

      - - 自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中
        - 自定义属性获取是通过**getAttribute('属性')**获取
        - 但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性
        - H5给我们新增了自定义属性：



- - - - - - 设置H5自定义属性：H5规定自定义属性data-开头作为属性名并且赋值，例：**<div data-index="1"></div>** 或者使用JS设置：**element.setAttribute('data-index' , 2)**



- - - - - - 获取H5自定义属性

          - - 兼容性获取：**element.getAttribute('data-index') （常用）**
            - H5新增：**element.dataset.index** 或者 **element.dataset['index'] （不常用）**



- - - 节点操作



- - - - 节点拥有：**nodeType**（节点类型）、**nodeName**（节点名称）和**nodeValue**（节点值）三个基本属性



- - - - 元素节点nodeType为1，属性节点nodeType为2，文本节点nodeType为3（文本节点包含文字、空格、换行等）   P.S.在实际开发中，节点操作主要操作的是**元素节点。**



- - - - 节点层级：利用DOM树可以把节点划分为不同的层级关系，常见的是父子兄层级关系



- - - - - 父级节点：**node.parentNode**

        - - **parentNode**属性可返回某节点的父节点，注意是**最近的一个父节点**
          - 如果指定的节点**没有父节点**，则返回**null**



- - - - - 子节点：



- - - - - - **父节点.childNodes**（标准）（**不提倡使用**）

          - - 返回包含指定节点的子节点的**集合**，该集合为**即时更新**的集合。
            - 注意：返回值里面包含了所有的子节点，包括元素节点、文本节点等。如果只想要获得里面的元素节点，则需要专门处理。所以**一般不提倡使用childNodes**



- - - - - - **父节点.children**（非标准）（**实际开发常用**）

          - - 它是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返回（**重点**）
            - 虽然**children**是一个非标准，但得到了各个浏览器支持，因此**可以放心使用**



- - - - - - **父节点.firstchild（不推荐）**：返回第一个子节点，不管是文本节点还是元素节点



- - - - - - **父节点.lastchild（不推荐）：**返回最后一个子节点，不管是文本节点还是元素节点



- - - - - - **父节点.firstElementChild（有兼容性问题，IE9+）**：返回第一个子元素节点



- - - - - - **父节点.lastElementChild（有兼容性问题，IE9+）**：返回最后一个子元素节点



- - - - - - **第一个子元素节点 实际开发的写法：父节点.children[0]（推荐）**



- - - - - - **最后一个子元素节点 实际开发的写法：父节点.children[父节点.children.length - 1]（推荐）**



- - - - - 兄弟节点（**不常用**）：



- - - - - - **node.nextSibling**：返回当前元素的下一个兄弟节点，找不到则返回null（包含所有节点）



- - - - - - **node.previousSibling**：返回当前元素上一个兄弟节点，找不到则返回null（包含所有节点）



- - - - - - **node.nextElementSibling（有兼容性问题，IE9+）**：返回下一个兄弟**元素**节点



- - - - - - **node.previousElementSibling（有兼容性问题，IE9+）**：返回下一个兄弟**元素**节点



- - - - 要想在页面中添加元素：1. 创建元素 2. 添加元素



- - - - - 创建节点：**document.createElement('tagname')**（**动态创建元素节点**）



- - - - - 添加节点

        - - **node.appendChild(child)**（将一个节点添加到指定父节点的子节点列表末尾，类似于CSS中的after伪元素）
          - **node.insertBefore(child, 指定元素)**（将一个节点添加到父节点的指定子节点前面，类似于CSS中的before伪元素）



- - - - - 删除节点

        - - **node.removeChild(child)**：从DOM中删除一个子节点，返回删除的节点



**P.S.如果需要阻止<a>标签链接跳转，则将href中内容改为"javascript:;"**



- - - - - 复制节点

        - - **node.cloneNode()**：返回调用该方法的节点的一个副本，也称为克隆节点
          - 注意：如果括号中的参数为空或者为**false**，则是**浅拷贝**，即只克隆复制节点本身，不克隆里面的子节点
          - 如果括号中的参数为**true**，则是**深拷贝**，复制标签并复制里面的内容



- 三种动态创建元素区别



- - **document.write()**（了解即可）：直接将内容写入页面的内容流，但是文档执行完毕，则它会导致页面全部重绘



- - **element.innerHTML**：是将内容写入某个DOM节点，不会导致页面重绘。创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂



- - **document.createElement()**：创建多个元素效率稍低一点点，但是结构更清晰



- DOM重点核心（**总结**）：关于DOM操作，主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作



- - 创建

  - - **document.write**
    - **innerHTML**
    - **createElement**



- - 增

  - - **appendChild**
    - **insertBefore**



- - 删

  - - **removeChild**



- - 改：主要修改DOM的元素属性，DOM元素的内容、属性，表单的值等

  - - 修改元素属性：src、href、title等
    - 修改普通元素内容：**innerHTML**、**innerText**
    - 修改表单元素：**value**、**type**、**disabled**等
    - 修改元素样式：**style**、**className**



- - 查：主要获取查询DOM的元素

  - - DOM提供的API方法：getElementById、getElementByTagName 古老用法 **不太推荐**
    - H5提供的新方法：**querySelector**、**querySelectorAll** **提倡使用**
    - 利用节点操作获取元素：父（**parentNode**）、子（**children**）、兄（**previousElementSibling**、**nextElementSibling**）**提倡使用**



- - 属性操作：主要针对自定义属性

  - - **setAttribute**：设置DOM的属性值
    - **getAttribute**：得到DOM的属性值
    - **removeAttribute**：移除属性



- - 事件操作

  - - **onclick**：鼠标点击左键触发
    - **onmouseover**：鼠标经过触发
    - **onmouseout**：鼠标离开触发
    - **onfocus**：获得鼠标焦点触发
    - **onblur**：失去鼠标焦点触发
    - **onmousemove**：鼠标移动触发
    - **onmouseup**：鼠标弹起触发
    - **onmousedown**：鼠标按下触发



- 事件高级



- - 注册事件（绑定事件）：给元素添加事件，称为**注册事件**

  - - 注册事件有两种方式：传统方式和方法监听注册方式



- - - - 传统注册方式:

      - - 利用on开头的事件onclick
        - 特点：注册事件的**唯一性**，同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数



- - - - 方法监听注册方式（**推荐方式**）：

      - - **addEventListener()**它是一个方法，IE9以前不支持这个方法，可使用attachEvent()代替（但attachEvent()不是标准，也**不推荐**使用）
        - 特点：同一个元素同一个事件可以注册多个监听器
        - 按注册顺序依次执行



- - - - **addEventListener**事件监听方式：**eventTarget.addEventListener(type, listener[, useCapture])**

      - - **eventTarget.addEventListener()**方法将指定的监听器注册到eventTarget(目标对象)上，当该对象触发指定的事件时，就会执行事件处理函数

        - 该方法接收三个参数：

        - - **type**：事件类型字符串，比如**'click'**、**'mouseover'**，注意这里不要带on
          - **listener**：事件处理函数，事件发生时，会调用该监听函数
          - **useCapture**：可选参数，是一个布尔值，默认是**false**。



- - 删除事件（解绑事件）：

  - - 删除事件的方式



- - - - 传统方式删除事件：**eventTarget.onclick = null;**



- - - - 方法监听注册方式删除事件：

      - - **eventTarget.removeEventListener(type, listener[, useCapture])**



- - DOM事件流：事件流描述的是从页面中接收事件的顺序。事件发生时会在元素节点之间按照特定的顺序传播，这个传播顺序即**DOM事件流**。

![截屏2022-07-10 18.31.06.png](blob:file:///d283d47c-e664-44e1-b0b8-b7ccc7a032d9)

- - - 捕获阶段：如果addEventListener第三个参数是true，那么处于捕获阶段
    - 冒泡阶段：如果addEventListener第三个参数是false 或者 省略，那么处于冒泡阶段
    - 实际开发很少使用事件捕获，我们**更关注事件冒泡**
    - 有些事件是没有冒泡的，比如**onblur**、**onfocus**、**onmouseenter**、**onmouseleave**



- - 事件对象

  - - **event**就是一个事件对象，写到我们侦听函数div.onclick = function(**event**) {} 的小括号里面，当形参来看
    - 事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数
    - 事件对象 是 我们事件的一系列相关数据的集合 跟事件相关的 比如鼠标点击里面就包含了鼠标的相关信息，鼠标坐标等。如果是键盘事件里面就包含的键盘事件的信息，比如：判断用户按下了哪个键
    - 这个事件对象我们可以自己命名，比如event、evt、e
    - 事件对象也有兼容性问题，IE678通过window.event 兼容性的写法 e = e || window.event;



- - 事件对象的常见属性和方法

  - - **e.target**：返回触发事件的对象（**标准**）（**this**返回的是绑定事件的对象（元素））
    - **e.preventDefault()**：该方法阻止默认事件（**标准** 比如不让链接跳转）
    - **e.stopPropagation()**：阻止冒泡（**标准**）
    - **e.type**：返回事件的类型，比如**click** **mouseover** 不带**on**
    - e.srcElement：返回触发事件的对象（非标准 IE6-8使用）
    - e.cancelBubble：该属性阻止冒泡（非标准 IE6-8使用）
    - e.returnValue：该属性 阻止默认事件（非标准 IE6-8使用 比如不让链接跳转）



- - 事件委托（代理、委派）

  - - **事件委托的原理：不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点**
    - **事件委托的作用：只操作了一次DOM，提高了程序的性能**



- - 鼠标事件对象

  - - **e.pageX**：返回鼠标相对于文档页面的X坐标 （IE9+支持）（**常用**）
    - **e.pageY**：返回鼠标相对于文档页面的Y坐标 （IE9+支持）（**常用**）
    - e.clientX：返回鼠标相对于浏览器窗口可视区的X坐标
    - e.clientY：返回鼠标相对于浏览器窗口可视区的Y坐标
    - e.screenX：返回鼠标相对于电脑屏幕的X坐标
    - e.screenY：返回鼠标相对于电脑屏幕的Y坐标



- - 常用键盘事件（如果使用**addEventListener**不需要加**on**）

  - - **onkeyup**：某个键盘按键被松开时触发（**常用**）
    - **onkeydown**：某个键盘按键被按下时触发（**常用**）
    - **onkeypress**：某个键盘按键被按下时触发（但是它不识别功能键，比如ctrl，shift，箭头等）
    - **优先级**：**down**＞**press**＞**up**



- - 键盘事件对象

  - - **e.key**
    - **e.code**

![截屏2022-07-11 18.11.07.png](blob:file:///eccb5b0d-79d1-47da-b5ac-1be864217f3a)



\--------------------------------------------------------------------------------------------------------------------------------------------------------------------------



- BOM：浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是window。BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。（BOM比DOM更大，包含了DOM）



- - BOM的构成

  - - **window对象是浏览器的顶级对象**，它具有双重角色

    - - 它是JS访问浏览器窗口的一个接口
      - 它是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法
      - 在调用的时候可以省略window，前面学习的对话框都属于window对象方法，如**alert()**、**promt()**等
      - window下的一个特殊属性**window.name**（因此在声明对象时不要以name为名）



- - window对象的常见事件



- - - 窗口加载事件

    - - **window.onload**是窗口（页面）加载事件，当文档内容完全加载完成会触发该事件（包括图像、脚本文件、CSS文件等），就调用的处理函数
      - 注意：有了**window.onload**就可以把JS代码写到页面元素的上方，因为**onload**是等页面元素全部加载完毕，再去执行处理函数。
      - **window.onload**传统注册事件方式只能写一次，如果有多个，会以最后一个**window.onload**为准
      - 如果使用**addEventListener('load', function(){})**则没有限制
      - 若图片很多，则可以使用**DOMContentLoaded**（是DOM加载完毕，不包含图片、flash、CSS等就可以执行，加载速度比**load**更快一些）



- - - 调整窗口大小事件

    - - **window.onresize**是调整窗口大小加载事件，当触发时就调用的处理函数
      - 一般用**window.addEventListener('resize', function(){})**
      - 注意：只要窗口大小发生像素变化，就会触发这个事件
      - 我们经常利用这个事件完成响应式布局。**window.innerWidth**当前屏幕的宽度



- - 定时器



- - - **window**对象给我们提供了两个非常好用的方法-定时器



- - - - **window.setTimeout(调用函数, [延迟的毫秒数]);** ：**setTimeout()**方法用于设置一个定时器，该定时器在定时器到期后执行调用函数

      - - **window**在调用的时候可以省略，即**setTimeout(function, 2000); （延时时间单位是毫秒，但是可以省略，如果省略默认是0）**

        - 页面中可能有很多的定时器，我们经常给定时器加标识符（名字，如timer1, timer2）

        - **setTimeout()**这个调用函数我们也称为**回调函数callback（**普通函数是按照代码顺序直接调用，而这个函数**需要等待**时间，时间到了才去调用这个函数，因此称为**回调函数）**

        - 停止**setTimeout()**定时器

        - - **window.clearTimeout(timeoutID)**：**clearTimeout()**方法取消了先前通过调用**setTimeout()**建立的定时器

          - - 注意：**window**可以省略



- - - - **window.setInterval(回调函数, [间隔的毫秒数]);**：**setInterval()**方法重复调用一个函数，每隔这个时间，就去调用一次回调函数

      - - 注意：window可以省略
        - 间隔的毫秒数省略默认是0，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数
        - 因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。



- - - - **setTimeout()和setInterval()区别**

      - - **setTimeout()**：延时时间到了，就去调用这个回调函数，只调用一次，就结束了这个定时器
        - **setInterval()**：每隔这个延时时间，就去调用这个回调函数，会调用很多次，重复调用这个函数



- - - **this**：**this**的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this最终指向的是那个调用它的对象

    - - 全局作用域或者普通函数中**this**指向全局对象**window**（注意定时器里面的**this**指向**window**）
      - 方法调用中谁调用**this**就指向谁
      - 构造函数中**this**指向构造函数的实例



- - JS执行机制



- - - JS是单线程：JS语言的一大特点就是**单线程**，也就是说，**同一个时间只能做一件事**。这是因为JS这门脚本语言诞生的使命所致--JS是为处理页面中用户的交互，以及操作DOM而诞生的。比如我们对某个DOM元素进行添加和删除操作，不能同时进行。应该先进行添加，之后再删除。



- - - **同步**和**异步**：为了解决**设置一个定时器会影响之后的代码运行**的问题，利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JS脚本创建多个线程。于是，JS中出现了**同步**和**异步**。



- - - - **同步**：前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟后），再去切菜、炒菜。



- - - - **异步**：你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法：我们在烧水的同时，利用这10分钟去切菜、炒菜。



- - - - 同步任务：同步任务都在主线程上执行，形成一个**执行栈**。



- - - - 异步任务：JS的异步是通过**回调函数**实现的。一般来说，异步任务有以下三种类型：

      - - 普通事件，如**click**、**resize**等
        - 资源加载，如**load**、**error**等
        - 定时器，包括**setInterval**、**setTimeout**等
        - 异步任务相关**回调函数**添加到**任务队列**中（任务队列也称为**消息队列**）



- - - - JS执行机制

      - - 先执行执行栈中的同步任务
        - 异步任务（回调函数）放入消息队列中
        - 一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取**消息队列**中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。



- - **location对象**：window对象给我们提供了一个**location属性**用于**获取或设置窗体的URL**，并且可以用于**解析URL**。因为这个属性返回的是一个对象，所以我们将这个属性也称为**location对象**



- - - URL：**统一资源定位符**，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。URL一般语法格式为：**protocol://host[:port]/path/[?query]#fragment**，例：http://www.itcast.cn/index.html?name=andy&age=18#link

    - - **protocol**：通信协议，常用的http,ftp,maito等
      - **host**：主机（域名） www.itheima.com
      - **port**：端口号 可选，省略时使用方案的默认端口，如http的默认端口为80
      - **path**：路径 由零或多个'/'符号隔开的字符串，一般用来表示主机上的一个目录或文件地址
      - **query**：参数 以键值对的形式，通过 & 符号分割开来
      - **fragment**：片段 # 后面内容 常见于链接 锚点



- - - location对象的属性

    - - **location.href**：获取或者设置 整个URL
      - **location.search**：返回参数
      - location.host：返回主机（域名）
      - location.port：返回端口号 如果未写 返回空字符串
      - location.pathname：返回路径
      - location.hash：返回片段 井号后面内容 常见于链接 锚点



- - - location对象的方法

    - - **location.assign()**：跟href一样，可以跳转页面（也称为重定向页面，可以后退页面）
      - **location.replace()**：替换当前页面，因为不记录历史，所以不能后退页面
      - **location.reload()**：重新加载页面，相当于刷新按钮或者F5 如果参数为true 强制刷新 ctrl+F5



- - navigator对象：包含有关浏览器的信息，它有很多属性，我们最常用的是userAgent，该属性可以返回由客户机发送服务器的user-agent头部的值



- - history对象：window对象给我们提供了一个history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL。

  - - **back()**：可以后退功能
    - **forward()**：前进功能
    - **go(参数)**：前进后退功能 参数如果是1 前进1个页面 如果是-1 后退1个页面



\--------------------------------------------------------------------------------------------------------------------------------------------------------------------------



- PC端网页特效



- - 元素偏移量offset系列



- - - offset概述：offset翻译过来就是偏移量，我们使用offset系列相关属性可以**动态的**得到该元素的位置（偏移）、大小等

    - - 获得元素距离带有定位父元素的位置
      - 获得元素自身的大小（宽度高度）
      - 注意：返回的数值都不带单位



- - - offset系列常用属性

    - - **element.offsetParent**：返回作为该元素带有定位的父级元素 **如果父级都没有定位则返回body（parentNode方法返回的是最近一级的父亲，不管父亲有没有定位）**
      - **element.offsetTop**：返回元素相对**带有定位父元素**上方的偏移
      - **element.offsetLeft**：返回元素相对**带有定位父元素**左边框的偏移
      - **element.offsetWidth**：返回自身包括padding、边框、内容区的宽度，返回数值不带单位
      - **element.offsetHeight**：返回自身包括padding、边框、内容区的高度，返回数值不带单位



- - - offset与style区别

    - - offset

      - - offset可以得到任意样式表中的样式值
        - offset系列获得的数值是没有单位的
        - offsetWidth包含padding+border+width
        - offsetWidth等属性是只读属性，只能获取不能赋值
        - **所以，我们想要获取元素大小位置，用offset更合适**

      - style

      - - style只能得到行内样式表中的样式值
        - style.width获得的是带有单位的字符串
        - style.width获得不包含padding和border的值
        - style.width是可读写属性，可以获取也可以赋值
        - **所以，我们想要给元素更改值，则需要用style改变**



- - 元素可视区client系列



- - - client概述：client翻译过来就是客户端，我们使用client系列的相关属性来获取元素可视区的相关信息。通过client系列的相关属性可以动态的得到该元素的边框大小、元素大小等。



- - - client系列常用属性

    - - **element.clientTop**：返回元素上边框的大小
      - **element.clientLeft**：返回元素左边框的大小
      - **element.clientWidth**：返回自身包括padding、内容区的宽度，**不含边框**，返回数值不带单位
      - **element.clientHeight**：返回自身包括padding、内容区的高度，**不含边框**，返回数值不带单位



- - 立即执行函数：不需要调用，立马能够自己执行的函数

  - - 写法：**(function() {})()** 或 **(function(){}())**  第二个小括号可以看做是调用函数
    - 主要作用：创建一个独立的作用域。避免了命名冲突问题。



- - 元素滚动scroll系列



- - - 元素scroll系列属性：scroll翻译过来就是滚动的，我们使用scroll系列的相关属性可以动态的得到该元素的大小、滚动距离等。



- - - scroll系列常用属性

    - - **element.scrollTop**：返回**被卷去的**上侧距离，返回的数值不带单位
      - **element.scrollLeft**：返回**被卷去的**左侧距离，返回的数值不带单位
      - **element.scrollWidth**：返回自身**实际的**宽度，**不含边框**，返回数值不带单位
      - **element.scrollHeight**：返回自身**实际的**高度，**不含边框**，返回数值不带单位



- - 鼠标事件mouseenter和mouseover的区别



- - - 当鼠标移动到元素上时就会触发mouseenter事件
    - 类似mouseover，它们两者之间的差别是：mouseover鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter只会经过自身盒子触发
    - 之所以这样，是因为mouseenter不会冒泡
    - 跟mouseenter搭配 鼠标离开mouseleave 同样不会冒泡



- - 动画函数封装



- - - 动画实现原理：通过定时器**setInterval()**不断移动盒子位置



- - - 实现步骤

    - - 获得盒子当前位置
      - 让盒子在当前位置加上一个移动距离
      - 利用定时器不断重复这个操作
      - 加一个结束定时器的条件
      - 注意此元素需要**添加定位**，才能使用**element.style.left**



- - - 动画函数简单封装：注意函数需要传递两个参数，**动画对象**和**移动到的距离**

```javascript
//简单动画函数封装：obj目标对象 target目标位置
function animate(obj, target){
  var timer = setInterval(function(){
    if(obj.offsetLeft >= target){
      //停止动画 本质是停止定时器
      clearInterval(timer);
    }
    obj.style.left = obj.offsetLeft + 1 + 'px';
  },30);
}

var div = document.querySelector('div');
var span = document.querySelector('span');
//调用函数
animate(div, 300);
animate(span, 200);
```





- - - 动画函数给不同元素记录不同定时器：如果多个元素都使用这个动画函数，每次都要var声明定时器。我们可以给不同的元素使用不同的定时器（自己专门用自己的定时器）

    - - 核心原理：利用JS是一门动态语言，可以很方便的给当前对象添加属性

```javascript
function animate(obj, target){
  //当我们不断点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
  //解决方案就是 让我们元素只有一个定时器执行
  //先清除以前的定时器，只保留当前的一个定时器执行
  clearInterval(obj.timer)
  obj.timer = setInterval(function(){
    if(obj.offsetLeft >= target){
      //停止动画 本质是停止定时器
      clearInterval(obj.timer);
    }
    obj.style.left = obj.offsetLeft + 1 + 'px';
  },30);
}
```



- - - 缓动效果原理：缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来

    - - 思路

      - - 让盒子每次移动的距离慢慢变小，速度就会慢慢落下来
        - 核心算法：（目标值-现在的位置）/ 10 作为每次移动的距离 步长



- - - 动画函数多个目标值之间移动：可以让动画函数从800移动到500

    - - 当我们点击按钮的时候，判断步长是正值还是负值：

      - - 如果是正值，则步长往大了取整（**Math.ceil**）
        - 如果是负值，则步长往小了取整（**Math.floor**）



- - - 给动画函数添加回调函数

    - - 回调函数原理：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫**回调**。
      - 回调函数写的位置：定时器结束的位置。



- - - 动画函数封装到单独JS文件里面：因为以后经常使用这个动画函数，可以单独封装到一个JS文件里面，使用的时候引用这个JS文件即可

    - - 单独新建一个JS文件

```javascript
function animate(obj, target, callback){
  //当我们不断点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
  //解决方案就是 让我们元素只有一个定时器执行
  //先清除以前的定时器，只保留当前的一个定时器执行
  clearInterval(obj.timer)
  obj.timer = setInterval(function(){
    //步长值写到定时器的里面
    //把步长值改为整数 不要出现小数问题
    //var step = Math.ceil((target - obj.offsetLeft) / 10);
    var step = (target - obj.offsetLeft) / 10;
    step = step > 0 ? Math.ceil(step) : Math.floor(step);
    if(obj.offsetLeft == target){
      //停止动画 本质是停止定时器
      clearInterval(obj.timer);
      //回调函数写到定时器结束里面
      if(callback){
        //调用函数
        callback();
      }
    }
    //把每次加1 这个步长值改为一个慢慢变小的值 步长公式：（目标值-现在的位置）/10
    obj.style.left = obj.offsetLeft + step + 'px';
  },30);
}
```





- - - 节流阀：防止轮播图按钮连续点击造成播放过快

    - - 节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。
      - 核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。
      - 开始设置一个变量**var flag = true;**  **if(flag) {flag = false; do something}** 关闭水龙头
      - 利用回调函数，动画执行完毕，**flag = true** 打开水龙头



\--------------------------------------------------------------------------------------------------------------------------------------------------------------------------



- 本地存储：随着互联网的发展，基于网页的应用越来越普遍，同时也变得越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。



- - 本地存储特性

  - - 数据存储在用户浏览器中
    - 设置、读取方便、甚至页面刷新不丢失数据
    - 容量较大，sessionStroage约5M、localStorage约20M
    - 只能存储字符串，可以将对象**JSON.stringify()**编码后存储



- - 本地存储之**window.sessionStorage**

  - - 生命周期为关闭浏览器窗口
    - 在同一个窗口（页面）下数据可以共享
    - 以键值对的形式存储使用
    - 存储数据：**sessionStorage.setItem(key, value)**
    - 获取数据：**sessionStorage.getItem(key)**
    - 删除数据：**sessionStorage.removeItem(key)**
    - 删除所有数据：**sessionStorage.clear()**



- - 本地存储之**window.localStorage**

  - - 生命周期永久生效，除非手动删除，否则关闭页面也会存在
    - 可以多窗口（页面）共享（同一浏览器可以共享）
    - 以键值对的形式存储使用
    - 存储数据：**localStorage.setItem(key, value)**
    - 获取数据：**localStorage.getItem(key)**
    - 删除数据：**localStorage.removeItem(key)**
    - 删除所有数据：**localStorage.clear()**



\--------------------------------------------------------------------------------------------------------------------------------------------------------------------------



- 数据可视化



- - 常见的数据可视化库

  - - D3.js：目前Web端评价最高的JavaScript可视化工具库（入手难）
    - **ECharts.js**：百度出品的一个开源JavaScript数据可视化库
    - **Highcharts.js**：国外的前端数据可视化库，非商用免费，被许多国外大公司所使用
    - AntV：蚂蚁金服全新一代数据可视化解决方案
    - 等等



- - **Echarts**使用五部曲

  - - 下载并引入echarts.js文件 → 图表依赖这个**js库**
    - 准备一个具备大小的DOM容器 → 生成的图表会放入这个**容器**内
    - 初始化echarts实例对象 → **实例化**echarts对象
    - 指定配置项和数据（option） → 根据具体需求修改**配置**选项
    - 将配置项设置给echarts实例对象 → 让echarts对象根据修改好的配置**生效**



- - 具体步骤：

  - - 引入JS文件：**<script src="js/echarts.min.js"></script>**
    - 准备DOM容器：**<div class="box" style="width:600px;height:400px"></div>**
    - 初始化Echarts实例对象：**var myChart = echarts.init(document.querySelector('.box'));**
    - 指定配置项和数据(option)：

```javascript
//指定配置项和数据
var option = {
  title:{
    text:'Echarts 入门实例'
  },
  tooltip:{},
  legend:{
    data:['销量']
  },
  xAxis:{
    data:['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子']
  },
  yAxis:{},
  series:[
    {
      name:'销量',
      type:'bar',
      data:[5,20,36,10,10,20]
    }
  ]
};
myChart.setOption(option)
  
```





- - 相关配置

  - - title：标题组件
    - tooltip：提示框组件
    - legend：图例组件
    - toolbox：工具栏
    - grid：直角坐标系内绘图网格
    - xAxis：直角坐标系grid中的x轴
    - yAxis：直角坐标系grid中的y轴
    - series：系列列表。每个系列通过type决定自己的图表类型（什么类型的图标）
    - color：调色盘颜色列表

P.S.配置项了解即可，其余配置项查阅文档获得



\--------------------------------------------------------------------------------------------------------------------------------------------------------------------------